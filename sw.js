// Custom Service Worker with Push Notification Support
// This file will be used as the source for next-pwa

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Precache all assets generated by next-pwa
// next-pwa uses injectManifest mode which requires the manifest placeholder to appear exactly once
// Workbox will replace the placeholder with the actual manifest during build
try {
  precacheAndRoute(self.__WB_MANIFEST);
  cleanupOutdatedCaches();
} catch (error) {
  console.error('[Service Worker] Error during precaching:', error);
  // Continue execution even if precaching fails
}

// Register routes for caching
registerRoute(
  '/',
  new NetworkFirst({
    cacheName: 'start-url',
    plugins: [
      {
        cacheWillUpdate: async ({ request, response, event, state }) => {
          return response && response.type === 'opaqueredirect'
            ? new Response(response.body, {
                status: 200,
                statusText: 'OK',
                headers: response.headers,
              })
            : response;
        },
        handlerDidError: async ({ request }) => self.fallback(request),
      },
    ],
  }),
  'GET'
);

registerRoute(
  ({ request, url }) => {
    if (url.pathname.startsWith('/api')) return false;
    if (request.mode !== 'navigate') return false;
    if (url.pathname.startsWith('/auth')) return false;
    if (url.pathname.startsWith('/login')) return false;
    if (url.pathname.startsWith('/dashboard/login')) return false;
    return true;
  },
  new NetworkFirst({
    cacheName: 'pages-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60,
      }),
      new CacheableResponsePlugin({
        statuses: [200],
      }),
      {
        handlerDidError: async ({ request }) => self.fallback(request),
      },
    ],
  }),
  'GET'
);

registerRoute(
  ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
  new StaleWhileRevalidate({
    cacheName: 'static-resources-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24,
      }),
      {
        handlerDidError: async ({ request }) => self.fallback(request),
      },
    ],
  }),
  'GET'
);

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      {
        handlerDidError: async ({ request }) => self.fallback(request),
      },
    ],
  }),
  'GET'
);

registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 30,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      {
        handlerDidError: async ({ request }) => self.fallback(request),
      },
    ],
  }),
  'GET'
);

// ===== PUSH NOTIFICATION HANDLING =====

// Listen for push events
self.addEventListener('push', function (event) {
  console.log('[Service Worker] Push notification received', event);
  console.log('[Service Worker] Push data:', event.data ? 'Has data' : 'No data');

  let notificationData = {
    title: 'ICF Log',
    body: 'You have a new notification',
    icon: '/icons/icon-192.png',
    badge: '/icons/icon-192.png',
    tag: 'icf-log-notification',
    requireInteraction: false,
    data: {
      url: '/',
    },
  };

  // Try to parse the push data
  if (event.data) {
    try {
      const data = event.data.json();
      console.log('[Service Worker] Parsed JSON data:', data);
      if (data.title) notificationData.title = data.title;
      if (data.body) notificationData.body = data.body;
      if (data.url) notificationData.data.url = data.url;
      if (data.icon) notificationData.icon = data.icon;
    } catch (e) {
      console.log('[Service Worker] JSON parse failed, trying text:', e);
      // If JSON parsing fails, try text
      try {
        const text = event.data.text();
        console.log('[Service Worker] Text data:', text);
        if (text) {
          const parsed = JSON.parse(text);
          console.log('[Service Worker] Parsed text as JSON:', parsed);
          if (parsed.title) notificationData.title = parsed.title;
          if (parsed.body) notificationData.body = parsed.body;
          if (parsed.url) notificationData.data.url = parsed.url;
        }
      } catch (e2) {
        console.error('[Service Worker] Failed to parse push data:', e2);
        // Use default notification
      }
    }
  }

  console.log('[Service Worker] Showing notification:', notificationData);

  // Show the notification
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: notificationData.badge,
      tag: notificationData.tag,
      requireInteraction: notificationData.requireInteraction,
      data: notificationData.data,
      actions: [
        {
          action: 'open',
          title: 'Open',
        },
        {
          action: 'close',
          title: 'Close',
        },
      ],
    }).then(() => {
      console.log('[Service Worker] Notification shown successfully');
    }).catch((error) => {
      console.error('[Service Worker] Failed to show notification:', error);
    })
  );
});

// Listen for notification clicks
self.addEventListener('notificationclick', function (event) {
  console.log('[Service Worker] Notification clicked');

  event.notification.close();

  if (event.action === 'close') {
    return;
  }

  // Open the app
  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    clients
      .matchAll({
        type: 'window',
        includeUncontrolled: true,
      })
      .then(function (clientList) {
        // Check if there's already a window/tab open with the target URL
        for (let i = 0; i < clientList.length; i++) {
          const client = clientList[i];
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // If no window is open, open a new one
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Listen for notification close events
self.addEventListener('notificationclose', function (event) {
  console.log('[Service Worker] Notification closed');
});

